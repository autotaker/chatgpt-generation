---
tags: Java CI whi-advent
title: 新卒１年目が荒れ果てた開発環境に１年間でCIを導入し単体テストを布教した話 - 2
---
# ステップ3: Gradle化 
*とあるライブラリの身元特定（バージョニング）*

プレマージを導入した後、今後SpotBugs等のLinterやJUnitを整備していきたいと考えていました。
しかし、それらのツールをビルドツールの助けなしで整備するのは骨が折れるため、
先にビルドスクリプトをAntからGradleに移行することにしました。

また、外部ライブラリの管理を温かみのある**ベタ書きシェルスクリプト**で行っていたため、
ライブラリ更新時の変更箇所が多く、工数がかかると言う問題も解決することにしました。

## 目標

- Antで書かれたビルドスクリプトをGradleに移行する
- シェルスクリプトで管理されていた外部ライブラリをGradleのdependencyで管理する

## 課題

- 既存のAntのビルドスクリプトのメンテナはいない。あるのはAntのXMLのみ。
- 外部ライブラリは社内のmavenレポジトリに再ホストされており、それらバージョン情報や依存ライブラリの情報が失われているため、各ライブラリがMaven Centralのどのバージョンに対応するものか特定する必要がある

## 古代技術の再現
メンテナ不在のなか、絶対にデグレードを起こしたくなかったので、
ビルド結果に意図しない変更が起こらないように**テスト駆動開発**でGradleスクリプトを作成しました。

つまり、Antでのビルド結果と比較して

- 生成されるクラスファイルがバイナリ一致すること
- 生成される各Jarに含まれるファイル名に意図しない変更がないこと
- 生成されるWarに含まれるファイル名に意図しない変更がないこと

をテストするスクリプトを書き、
テストに通るようにGradleスクリプトを書いていきました。

## ご注文はライブラリですか？
外部ライブラリの依存関係解決をGradleに任せるためには、失われた各ライブラリの依存情報を再構築する必要がありました。
そのため、社内ホストされた外部ライブラリを一つ一つ展開し、バージョンの特定を行いました。

特定は簡単なものもあれば難しいものもありました。難易度順で並べると以下のようでした。

- Easy: ファイル名にバージョンが書いてあるもの
- Medium: Jarの中にpomファイルがあるもの
- Hard: Jarの中の`META-INF/MANIFEST.MF`にそれっぽい情報があるもの
- Extreme: No hints (WEB上で存在する同名Jarを虱潰しで特定できることも）

バージョンがわかったからと言って安易に差し替えてはいけません。
もしかしたらホストする際に別のバージョンをアップロードしている可能性や、Jarの一部のファイルを差し替えている可能性もあります。

バージョンのずれによるデグレードを避けるために、
二つのJarが同じバージョンかどうかを以下の基準で判定するスクリプトを書き、
確認をしながら特定を進めていきました。

- 二つのJarのハッシュ値が等しい場合は同じバージョン
- そうでない場合、二つのJarに含まれるファイルがMETA-INF以下をのぞいて全て等しい場合は同じバージョン
- そうでない場合、差分のあるファイルを確認し、同じバージョンか人間が判断する。

このようにした結果、主要な外部ライブラリについては安全にバージョンを特定することができました。
一方、特定できなかったものについてはそのまま残すこととしました。

## 効果
Gradleに移行したことで外部ライブラリ周りの更新が非常に楽になりました。

- これまで外部ライブラリに更新があったときに各開発者がローカルで更新スクリプトを手動実行する作業がなくなった
- ライブラリのバージョンを安全に更新できるようになった。

# ステップ4: JUnit復活
*俺、このテストが動いたら退勤するんだ*

ようやくGradleに移行できたので次はJUnitの整備です。
JUnitテストは昔に書かれたテストがそれなりに存在していたのですが、
開発者がローカルのEclipseで動かしてテストするという運用になっており、

- 全JUnitの定期的な実行
- プレマージチェックでのJUnitの実行
は行われていませんでした。

また、既存のJUnitテストを動かすにもライブラリが足りておらず、
必要なライブラリを各開発者がクラスパスに手動で追加する必要がありました。

## 目標
- `gradle test`で全テストが実行できるようにする
- Eclipse上で特に追加設定なしにJUnitを実行できるようにする
- プレマージチェックで変更のあったクラスに対応するJUnitテストがあれば実行する
  - 例： `SomeService.java`を修正したら、`SomeServiceTest.java`を実行。
  - 実行結果とカバレッジをGitLab上から簡単に確認できるように
  - テストが失敗したらビルドエラーと同様にパイプラインを失敗させ開発者に通知する
- 日次で全JUnitを実行し、結果サマリをSlackに投稿する

## 動かないテスト
まず、既存のJUnitを動かせるように`build.gradle`にテスト用のライブラリを足して、`gradle test`を実行してみました。

```console
> gradlew test
....
....
....
```

いくつもの問題のあるテストがあり、全てを動かすの一筋縄ではいきませんでした。
例をあげると


- 無限ループするテスト
- `System.exit(0)`を呼び出すテスト（←マジでEvil）
- 開発DBに接続しにいくテスト

等がありました。テストがハングしている雰囲気を察して、
問題のあるテストを特定し、除外していくことを繰り返すと
ようやく全テスト実行が終了するようになりました。

## 遅すぎるテスト
しかし、全テストを実行するのに20分程度かかっていました。
テストケース数から鑑みても遅すぎるので
遅い原因を調査していくと以下の二つが主な原因でした。

- 同じテストが複数回実行されている
- DBに接続しようとしてタイムアウトしている

### テストの重複
テストの重複は、TestSuiteクラスが原因でした。すなわち、

```yaml
HogeSuite.java
 - FugaTest.java
 - PiyoTest.java
 - FooSuite.java
   - BarTest.java
   - BazTest.java
```

のように階層化されたTestクラスとTestSuiteクラスがあった場合、
素朴に全クラスを実行すると、Suiteクラスからの実行とTestクラスの単体実行が重複してしまうのです。

```yaml
- FugaTest
- PiyoTest
- BarTest
- BazTest
- FooSuite:BarTest
- FooSuite:BazTest
- HogeSuite:FugaTest
- HogeSuite:PiyoTest
- HogeSuite:FooSuite:BarTest
- HogeSuite:FooSuite:BazTest
```

今回の場合Suiteクラスである必要は特になかったのでSuiteクラスはテストの対象から除外することにしました。

### DBにつなぐテスト
残るはDBに接続する必要のあるテストでした。
DBにつなぐ必要のあるテストは遅くて不安定であるため、
プレマージでの実行対象からは除外することにしました。

DBアクセスするテストの多くは古い時代に書かれたJUnit3のテストでした。
ご存知の通りJUnit3では`TestCase`クラスのサブクラスとしてテストを書きます。
そして、本プロダクトでは独自の`TestCase`のサブクラスをテストの
基底クラスとしていたのですが、その基底クラスがDBに接続する仕様になっていました。

そのため、**テスト自体はDBアクセスを必要としないが、独自の基底クラスを継承している故にDBアクセスをしているテスト**が相当数あることが予想されました。
そのようなテストまで除外してしまうのはもったいないので、以下のやり方で修正することにしました。

1. 継承の親クラスを`TestCase`クラスに変更する
2. そのクラスのビルドが通り、実行した際に１つ以上のテストケースが成功する場合、プレマージでの実行対象とする。
3. そうでない場合（コンパイルが通らない場合または全てのテストケースが失敗する場合）、修正を元に戻し、プレマージでの実行対象から外す。

これで動くテストを抽出することができ、20分かかっていたテストも**2分程度**で終わるようになりました。

## 失敗するテスト
最後に導入時点で失敗しているテストをIgnoreする修正を行いました。

- JUnit4テストの場合、`@Ignore`アノテーションをつける
- JUnit3テストの場合、テストメソッド名に`_`をつける（`testHoge` -> `_testHoge`)

これでめでたく`gradle test`で全テストが実行でき、かつ失敗件数を0件にすることができました。

## CIの整備
最後にプレマージでのテスト実行を整備しました。
`gradle test`では全てのテストを実行するので、
現時点では2分とはいえ、今後テスト件数が増えていくことを考えると、プレマージでの全件実行はできません。
したがって、修正したファイルに対応するテスト（末尾にTestがつくもの）のみを実行する仕様にしました。

また、gradleタスクでテストを実行する場合、普通にやるとgradleでのビルドが実行され、
5分ほど時間がかかってしまいます。
Lintエラーを出力する関係で、ビルドはgradleではなくEclipseを用いたいため、
Eclipseがコンパイルした結果を用いてテストを実行するgradleタスクを作成しました。

結果として、プレマージでのテストを**30秒程度**で実行することができるようになりました。

## 効果
JUnitのCIを整備したことで、テストを定期的に実行し、テストの失敗がメンテされる仕組みを作ることができました。

一方でテストを新規に書く人は残念ながらほとんど増えませんでした。

# ステップ5: JUnit道場 
*やってみせ、言って聞かせて、させてみせ、ほめてやらねば、人は動かじ*

上記の通り、プレマージでJUnitを動かすようにしたのですが、ユニットテストを書く開発者はほとんど増えませんでした。

ユニットテストには以下のようなメリットがあります。

- サーバを起動しなくて良いため確認が速く、繰り返し実行できる
- プレマージで自動実行されるため、評価時の手動テスト実行が一部[^5]不要に
- 日次実行されるため、多くのテストを整備することで長期的にデグレードの早期発見が可能になる

[^5]: もちろんE2Eテストじゃないと評価できないものもあります。

## 目標
JUnitをコンスタントに書く文化を開発者に根付かせることを目標にしました。

### 現状の可視化
しかし、上の目標はまだ曖昧です。

まず、具体的な目標数値を設定するために現状の可視化を行いました。
テストの日次実行の結果を集計用DBに突っ込み、
Metabaseを使ってダッシュボードを作成し、どの部署がどのくらいテストを書いているのかを可視化しました。[^8]

[^8]: ダッシュボードは毎日眺めているだけで仕事した気になるのでとても良いですね。

![image2.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/67228/ee55a8b2-74fa-d29f-cc69-046a407866d3.png)

ダッシュボードを観察していてわかったことは

1. テストの追加件数は10件/月程度である
2. テストを追加しているのは特定のごく少数の開発者に限られる

ということでした。したがってテストを増やしていくためには**テストを書く開発者を増やす**必要がありました。

### 目標数値
テストの追加件数を10件/月から100件/月にする。

## テストを書かない理由
テストを書いていない理由を考察してみたところ以下のような要因がありそうでした。

- そもそもJUnitの使い方を知らない 
- （E2Eテストではなく）ユニットテストを書くメリットを理解していない
- プロダクトのコードのテスト容易性が低くテストを書きたくてもかけない

## JUnit道場
テストを書く文化を根付かせるために、JUnitの書き方を教える研修（JUnit道場)を企画しました。

現場の開発者のテスト技術にもレベルがあることを考慮して以下のようなコンテンツを作成しました。

- 基礎編
  - 対象者： JUnitの書き方を知らない人向け
  - 参加者: 開発者40名程度
  - 形式: [developer dojo](https://note.com/works_hi/n/n4edd6784b632) (30 min x 4)
  - 内容: JUnit4 + hamcrest + Mockitoの基礎的な書き方をハンズオンでやってみる
- マインド編
  - 対象者: ユニットテストを書くメリットを知らない人向け
  - 参加者: 開発者４０名程度
  - 形式: オンラインYouTube鑑賞会
  - 内容: t_wadaさんの[TDDライブコーディング動画](https://www.youtube.com/watch?v=Q-FJ3XmFlT8)を鑑賞
- 実践編
  - 対象者: 基本的なJUnitは使えるがプロダクト開発でどうテストを書いたら良いかわからない人向け
  - 参加者: 各開発チームから2-3人(計十数名）
  - 形式: ライブコーディング(60min) + ハンズオン（60 min x 3)
  - 内容: [レガシーコード改善ガイド](https://www.amazon.co.jp/%E3%83%AC%E3%82%AC%E3%82%B7%E3%83%BC%E3%82%B3%E3%83%BC%E3%83%89%E6%94%B9%E5%96%84%E3%82%AC%E3%82%A4%E3%83%89-Object-Oriented-SELECTION-%E3%83%9E%E3%82%A4%E3%82%B1%E3%83%AB%E3%83%BBC%E3%83%BB%E3%83%95%E3%82%A7%E3%82%B6%E3%83%BC%E3%82%BA/dp/4798116831)からいくつかのテクニックを抜粋して[練習用のレガシーコード](https://github.com/autotaker/LegacyEx)上でリファクタリングしながらテストを書いてみる。

## 効果
JUnit道場を実施した結果

- これまでユニットテストを書いていたチームは「**息をするように**」テストを書くように
- これまでユニットテストを書いていなかったチームも所々テストを書くように

なりました。

定量的にも、JUnit道場前後でテスト追加件数が**10件/月から100件/月**に増えました。

今後もユニットテストをかける開発者が啓蒙活動を行なっていくことででテスト追加件数はさらに加速していくことが期待できます。

# まとめ
まだまだ道半ばなところはありますが、レガシーコードであっても粘り強く改善していった結果、
モダンな開発環境、開発手法を取り入れることができました。

１年間改善を続けて来て以下のような教訓を得ました。

- 改善は片手間ではできない。専任者を建て、十分な裁量を与えるべし。
- 環境をきれいにすることに集中する。コードによくないところがあっても直そうとすると泥沼。
- 施策を導入する前に、何を改善・削減するのかを明確にしておく。
- 訳のわからない仕様であっても必ずそうなった原因がある。可能な限りその仕様になった理由を探るべし。
- 使われていないコード、動かないテストは潔く切り捨てる。
- 文化を根付かせるためには技術や仕組みだけでは不十分。地道な啓蒙活動あるのみ。

Works Human Intelligenceではレガシーコードに立ち向かうエンジニアを募集しています！

長い記事に最後までお付き合いいただきありがとうございました。
明日の記事は@_53aさんの [テレワークをより快適にするソフトウェア n 選](https://qiita.com/_53a/items/5b6327db1d21ed6adf28)です。
